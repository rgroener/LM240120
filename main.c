/*
 * 
 * Library to graphic LCD Display
 * Resolution:	240 x 120
 * LCD:			 240120H
 * Controller:	UC1618T
 * 
 * RGroener
 * Compiler avr-gcc 
 * 
 * 
 * 
 * 
 * */
#define F_CPU 8000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include <inttypes.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>

#define RD_LOW			PORTC &= ~(1<<PC1)
#define RD_HIGH			PORTC |= (1<<PC1)
#define WR_LOW			PORTC &= ~(1<<PC2)
#define WR_HIGH			PORTC |= (1<<PC2)
#define DISPLAY_CONTROL	PORTC &= ~(1<<PC3)
#define DISPLAY_DATA	PORTC |= (1<<PC3)
#define RST_HIGH		PORTC |= (1<<PC4)
#define RST_LOW			PORTC &= ~(1<<PC4)
#define CS_HIGH 		PORTC |= (1<<PC5)
#define CS_LOW			PORTC &= ~(1<<PC5)
#define DATA_REGISTER 	PORTD

#define DATA 	1	
#define CONTROL 0
#define WRITE 1 
#define READ 0

#define _NOP() do { __asm__ __volatile__ ("nop"); } while (0)
// used for a very short delay


unsigned char font5x8[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,     //
  0x00,0x00,0x00,0x4F,0x00,0x00,     // !
  0x00,0x00,0x07,0x00,0x07,0x00,     // "
  0x00,0x14,0x7F,0x14,0x7F,0x14,     // #
  0x00,0x24,0x2A,0x7F,0x2A,0x12,     // $
  0x00,0x23,0x13,0x08,0x64,0x62,     // %
  0x00,0x36,0x49,0x55,0x22,0x50,     // &
  0x00,0x00,0x05,0x03,0x00,0x00,     // '
  0x00,0x00,0x1C,0x22,0x41,0x00,     // (
  0x00,0x00,0x41,0x22,0x1C,0x00,     // )
  0x00,0x14,0x08,0x3E,0x08,0x14,     // *
  0x00,0x08,0x08,0x3E,0x08,0x08,     // +
  0x00,0x00,0x50,0x30,0x00,0x00,     // ,
  0x00,0x08,0x08,0x08,0x08,0x08,     // -
  0x00,0x00,0x60,0x60,0x00,0x00,     // .
  0x00,0x20,0x10,0x08,0x04,0x02,     // /
  0x00,0x3E,0x51,0x49,0x45,0x3E,     // 0
  0x00,0x00,0x42,0x7F,0x40,0x00,     // 1
  0x00,0x42,0x61,0x51,0x49,0x46,     // 2
  0x00,0x21,0x41,0x45,0x4B,0x31,     // 3
  0x00,0x18,0x14,0x12,0x7F,0x10,     // 4
  0x00,0x27,0x45,0x45,0x45,0x39,     // 5
  0x00,0x3C,0x4A,0x49,0x49,0x30,     // 6
  0x00,0x01,0x71,0x09,0x05,0x03,     // 7
  0x00,0x36,0x49,0x49,0x49,0x36,     // 8
  0x00,0x06,0x49,0x49,0x29,0x1E,     // 9
  0x00,0x00,0x36,0x36,0x00,0x00,     // :
  0x00,0x00,0x56,0x36,0x00,0x00,     // ;
  0x00,0x08,0x14,0x22,0x41,0x00,     // <
  0x00,0x14,0x14,0x14,0x14,0x14,     // =
  0x00,0x00,0x41,0x22,0x14,0x08,     // >
  0x00,0x02,0x01,0x51,0x09,0x06,     // ?
  0x00,0x32,0x49,0x79,0x41,0x3E,     // @
  0x00,0x7E,0x11,0x11,0x11,0x7E,     // A
  0x00,0x7F,0x49,0x49,0x49,0x36,     // B
  0x00,0x3E,0x41,0x41,0x41,0x22,     // C
  0x00,0x7F,0x41,0x41,0x22,0x1C,     // D
  0x00,0x7F,0x49,0x49,0x49,0x41,     // E
  0x00,0x7F,0x09,0x09,0x09,0x01,     // F
  0x00,0x3E,0x41,0x49,0x49,0x7A,     // G
  0x00,0x7F,0x08,0x08,0x08,0x7F,     // H
  0x00,0x00,0x41,0x7F,0x41,0x00,     // I
  0x00,0x20,0x40,0x41,0x3F,0x01,     // J
  0x00,0x7F,0x08,0x14,0x22,0x41,     // K
  0x00,0x7F,0x40,0x40,0x40,0x40,     // L
  0x00,0x7F,0x02,0x0C,0x02,0x7F,     // M
  0x00,0x7F,0x04,0x08,0x10,0x7F,     // N
  0x00,0x3E,0x41,0x41,0x41,0x3E,     // O
  0x00,0x7F,0x09,0x09,0x09,0x06,     // P
  0x00,0x3E,0x41,0x51,0x21,0x5E,     // Q
  0x00,0x7F,0x09,0x19,0x29,0x46,     // R
  0x00,0x46,0x49,0x49,0x49,0x31,     // S
  0x00,0x01,0x01,0x7F,0x01,0x01,     // T
  0x00,0x3F,0x40,0x40,0x40,0x3F,     // U
  0x00,0x1F,0x20,0x40,0x20,0x1F,     // V
  0x00,0x3F,0x40,0x38,0x40,0x3F,     // W
  0x00,0x63,0x14,0x08,0x14,0x63,     // X
  0x00,0x07,0x08,0x70,0x08,0x07,     // Y
  0x00,0x61,0x51,0x49,0x45,0x43,     // Z
  0x00,0x00,0x7F,0x41,0x41,0x00,     // [
  0x00,0x15,0x16,0x7C,0x16,0x15,     // slash
  0x00,0x00,0x41,0x41,0x7F,0x00,     // ]
  0x00,0x04,0x02,0x01,0x02,0x04,     // ^
  0x00,0x40,0x40,0x40,0x40,0x40,     // _
  0x00,0x00,0x01,0x02,0x04,0x00,     // `
  0x00,0x20,0x54,0x54,0x54,0x78,     // a
  0x00,0x7F,0x48,0x44,0x44,0x38,     // b
  0x00,0x38,0x44,0x44,0x44,0x20,     // c
  0x00,0x38,0x44,0x44,0x48,0x7F,     // d
  0x00,0x38,0x54,0x54,0x54,0x18,     // e
  0x00,0x08,0x7E,0x09,0x01,0x02,     // f
  0x00,0x0C,0x52,0x52,0x52,0x3E,     // g
  0x00,0x7F,0x08,0x04,0x04,0x78,     // h
  0x00,0x00,0x44,0x7D,0x40,0x00,     // i
  0x00,0x20,0x40,0x44,0x3D,0x00,     // j
  0x00,0x7F,0x10,0x28,0x44,0x00,     // k
  0x00,0x00,0x41,0x7F,0x40,0x00,     // l
  0x00,0x7C,0x04,0x18,0x04,0x78,     // m
  0x00,0x7C,0x08,0x04,0x04,0x78,     // n
  0x00,0x38,0x44,0x44,0x44,0x38,     // o
  0x00,0x7C,0x14,0x14,0x14,0x08,     // p
  0x00,0x08,0x14,0x14,0x18,0x7C,     // q
  0x00,0x7C,0x08,0x04,0x04,0x08,     // r
  0x00,0x48,0x54,0x54,0x54,0x20,     // s
  0x00,0x04,0x3F,0x44,0x40,0x20,     // t
  0x00,0x3C,0x40,0x40,0x20,0x7C,     // u
  0x00,0x1C,0x20,0x40,0x20,0x1C,     // v
  0x00,0x3C,0x40,0x30,0x40,0x3C,     // w
  0x00,0x44,0x28,0x10,0x28,0x44,     // x
  0x00,0x0C,0x50,0x50,0x50,0x3C,     // y
  0x00,0x44,0x64,0x54,0x4C,0x44,     // z
  0x00,0x00,0x00,0x7F,0x00,0x00,     // |
  0x00,0x08,0x18,0x38,0x18,0x08,     //
  0x00,0x20,0x30,0x38,0x30,0x20,     
  0x00,0x08,0x08,0x2A,0x1C,0x08,     
  0x00,0x08,0x1C,0x08,0x08,0x0F,    
};


void glcd_rst(void)
{
	
	CS_HIGH;
	_delay_ms(3);
	RST_HIGH;
	_delay_ms(1);
	RST_LOW;
	_delay_ms(10);
	RST_HIGH;
	_delay_ms(10);
	CS_LOW;
}

//send Data / Control byte to graphic controller
//dc =1 = data; dc = 0 = control
void glcd_write(int dc, int data)
{
	if(dc==CONTROL)DISPLAY_CONTROL; else DISPLAY_DATA;//set dc pin according date to be sent
	PORTD = data;	//set date to be sent
	CS_HIGH;		//enable lcd
	RD_HIGH;		//write data; RD_LOW=read data
	WR_HIGH; 		//latch data into controller	
	WR_LOW;
	CS_LOW;			//disable lcd
}

void glcd_clear_screen(void)
{
	uint32_t x=0;
	
	for(x=0;x<8200;x++)
	{
		glcd_write(DATA, 0x00);
		//_delay_ms(1);
	}
	
}
void glcd_set_column(uint8_t lcdcolumn)//horizontal
{
	lcdcolumn+=14;//14 = column offset
	glcd_write(CONTROL, 0x00);glcd_write(CONTROL, lcdcolumn);glcd_write(CONTROL, 0x00);//set column to 0
	
}
void glcd_set_page(uint16_t lcdpage)//vertical
{
	/*Vertical
	 *lcdpage aufteilung von 16 bits auf 8 bit wenn pa4 gesetzt ist noch nicht gemacht 
	 */
	glcd_write(CONTROL, 96+lcdpage);//set page adress 0 (vertical) 96 weil 0b0110xxxx
	
	if(lcdpage<15)
	{
		glcd_write(CONTROL, 0b01110000);
	}
	else//set PA4 when page higher 15
	{
		glcd_write(CONTROL, 0b01110001);//set PA4 when page higher 15
	}
}
void glcd_init(void)
{
	glcd_rst();	//reset lcd
	WR_LOW;		//default value for WR /ready to latch data
	glcd_write(CONTROL, 0b00100100);//set temp compensation -0.5% /grad C
	glcd_write(CONTROL, 0b00101101);//set pump control internal 10x
	glcd_write(CONTROL, 0b10000100);//partial display control disabled
	glcd_write(CONTROL, 0b10000110);//interlace scan
	glcd_write(CONTROL, 0b11101011);//set bias ratio 11
	glcd_write(CONTROL, 0b10000001);glcd_write(CONTROL, 170);	//set elec Volume PM / double command
	glcd_write(CONTROL, 0b10101101);	//set display enable , b/w mode
	glcd_write(CONTROL, 0b10010101);
	
	glcd_write(CONTROL, 0x00);glcd_write(CONTROL, 0x00);glcd_write(CONTROL, 0x00);//set column to 0
	glcd_write(CONTROL, 0b10001001);//RAM adddres control /select vertical or horizontal write
	glcd_write(CONTROL,0b11000010);//Set LCD Mapping Control => Mirror Column
	glcd_set_page(0);
	glcd_clear_screen();
}
void glcd_write_char(uint8_t c)
{
	uint8_t count=0;
	uint16_t arrpos=32; //32 ASCII code f√ºr space
	
	c -= 32; // calculate position in font array
	arrpos = c*6;//multiply with 5 due to font with
	
	for(count=0; count<6 ; count++)
	{
		glcd_write(1,font5x8[arrpos+count]);
	}
	
	
	
}
void glcd_goto_xy(uint16_t col, uint8_t page)
{
	glcd_set_page(page);
	glcd_set_column(col);
	
}

void glcd_write_string(char *text)// writes string to display at current cursor position.
{
	
	
	for(;*text;text++)// for all non - nul chars
	{
		glcd_write_char(*text);// write the char
	}

}
void glcd_draw_bit(uint16_t col, uint8_t pag, uint8_t color)
{
	uint8_t lcddata=0;
	uint8_t vor=0;
	uint8_t nach=0;
	
	DDRD = 0x00; //PortD input to access SRAM Data
	//needs one cycle to access port data
	
	vor = pag/8;
	if(vor==0)
	{
		nach = pag;
	}else nach = pag-(vor*8);
	
	//select position in LCD SRAM
	glcd_set_page(vor);
	glcd_set_column(col);

	lcddata=PORTD;
	
	switch(nach)//-1 weil start bei bit 0 und nicht bit 1
	{
		case 0:	lcddata |= 0x01;
				break;
		case 1:	lcddata |= 0x02;
				break;
		case 2:	lcddata |= 0x04;
				break;
		case 3:	lcddata |= 0x08;
				break;
		case 4:	lcddata |= 0x10;
				break;
		case 5:	lcddata |= 0x20;
				break;
		case 6:	lcddata |= 0x40;
				break;
		case 7:	lcddata |= 0x80;
				break;
	}
	DDRD = 0xFF; //change back Port D to input
	_NOP();
	glcd_write(DATA, lcddata);
	
}
void glcd_draw_byte(uint16_t col, uint8_t pag, uint8_t data)
{
	
}
uint8_t glcd_read_byte(uint16_t col, uint8_t pag)
{
	DDRD=0x00; //Input to read sram data
	//PORTD=0xff; //pullups
	
	uint8_t tempdata=0;
	
	glcd_set_page(pag);
	glcd_set_column(col);
	
	DISPLAY_DATA;	//set dc pin according date to be sent
	CS_HIGH;		//enable lcd
	RD_LOW;			//read data
	WR_HIGH; 		//latch data into controller	
	WR_LOW;
	tempdata=PIND;
	CS_LOW;			//disable lcd
	
	DDRD=0xff; //output
	PORTD=0x00; //low
	
	return tempdata;
}


int main(void)
{
	
	DDRD = 0xFF;//Port D Output => Data register
	PORTD =0x00;//Low
	
	DDRC |= ((1<<PC1) |(1<<PC2) | (1<<PC3)| (1<<PC4)| (1<<PC5)); //RD,WR,D/C,RST,CS = Output
	PORTC &= ~((1<<PC1) |(1<<PC2) | (1<<PC3)| (1<<PC4)| (1<<PC5)); //RD,WR,D/C,RST,CS = Low
	
	DDRB |= (1<<PB0);
	PORTB |= (1<<PB0);
	//_delay_ms(5);	//delay for lcd to be stable
	glcd_rst();		//reset lcd
	glcd_init();	//initialise lcd
	
	
	

	glcd_clear_screen();
	
	
	/*glcd_draw_bit(200,0,1);
	_delay_ms(200);
	glcd_draw_bit(201,1,1);
	_delay_ms(200);
	glcd_draw_bit(202,2,1);
	_delay_ms(200);
	glcd_draw_bit(203,3,1);
	_delay_ms(200);
	glcd_draw_bit(204,4,1);
	_delay_ms(200);
	glcd_draw_bit(205,5,1);
	_delay_ms(200);
	glcd_draw_bit(206,6,1);
	_delay_ms(200);
	glcd_draw_bit(207,7,1);
	_delay_ms(200);
	glcd_draw_bit(208,8,1);
	_delay_ms(200);
	glcd_draw_bit(209,9,1);
	_delay_ms(200);
	
	for(xx=0;xx<120;xx++)
	{
		glcd_draw_byte(xx,5,0xff);//glcd_draw_bit(200,xx,1);
		//_delay_ms(200);
	}
		*/	
		
		//glcd_write(CONTROL, 0x00);glcd_write(CONTROL, 0x00);glcd_write(CONTROL, 0x00);//set column to 0
		
		
		glcd_goto_xy(0,0);
		glcd_write_string("Hello World");
	
	while(1)
	{
	
	
	
	
	
	
	
	
	
	
	
	}//end of while

}//end of main
